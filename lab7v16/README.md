# лабораторн аробота №7 
### варіант №16

## Опис
цей проєкт демонструє обробку IO/мережевих помилок та реалізацію патерну **Retry**

у програмі реалізовані:
- `FileProcessor` - імітує читання замовлень з файлу та генерує `IOException` перші 2 рази
- `NetworkClient` - імітує отримання замовлень з API та генерує `HttpRequestException` перші 3 рази
- `RetryHelper` - універсальний механізм повторних спроб з експоненційною затримкою та логуванням

## як це воркінг
1. **FileProcessor** перші 2 виклики кидає штучну помилку, після чого повертає список замовлень
2. **NetworkClient** перші 3 виклики імітує мережеву помилку, потім повертає правильні дані
3. **RetryHelper** повторює виконання операції кілька разів:
   - виводить інформацію про помилки
   - робить експоненційні затримки (0.4 с. -> 0.8 с. -> 1.6 с. -> …)
   - використовує `shouldRetry` для вибору, чи можна повторювати спробу

## приклад роботи програми  

![screenshot](./images/lab7v16.png)

## як запустити
```bash
g++ lab7v16.cpp -o lab7v16.exe
./lab7v16.exe
```

## контрольні питання
1. при роботі з файлами найчастіше виникають помилки, повʼязані з тим що файл не знайдено або шлях вказано неправильно
також файл може бути заблокований іншою програмою або система не дозволяє читати чи записувати дані, і тоді зʼявляються загальні помилки вводу виводу
під час роботи з мережею найчастіше виникають ситуації, коли сервер тимчасово не відповідає або інтернет зникає на кілька секунд
мережеві запити також можуть падати через повільний час відповіді або відмови сервера
загалом ці помилки не повʼязані з логікою програми, а з тим що зовнішній ресурс недоступний у певний момент
2. патерн retry базується на тому, щоб не здаватися з першої спроби, якщо операція завершилась невдало
ідея полягає в тому, щоб виконати операцію ще раз через певний час, якщо є шанс що проблема тимчасова
це корисно коли сервер підвисає, інтернет пропадає на секунду або файл коротко заблокований
retry допомагає програмі автоматично відновити роботу без участі користувача
але якщо помилка постійна, наприклад невірний шлях або некоректний формат, повтори не допоможуть і лише витратять час
3. експоненційна затримка означає що кожна наступна пауза між спробами збільшується вдвічі
це дозволяє не засипати ресурс нескінченними запитами, якщо він тимчасово недоступний
початкова затримка зазвичай невелика, наприклад пів секунди,
потім вона зростає до однієї секунди, потім до двох, потім до чотирьох...
такий підхід дає системі час стабілізуватися
реалізується це просто шляхом множення початкової затримки на два після кожної невдалої спроби
4. делегат shouldRetry існує для того, щоб вирішувати чи варто робити повторну спробу при конкретному типі помилки
не всі помилки мають сенс для повторення
тимчасові помилки мережі або вводу виводу можна повторити, бо вони можуть пройти самі по собі
але помилки на кшталт неправильного шляху або невірного формату не мають сенсу для повторів
shouldRetry дозволяє зробити retry більш розумним і уникати зайвих повторних спроб
що робить обробку помилок більш керованою і точною