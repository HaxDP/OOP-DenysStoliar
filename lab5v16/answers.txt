1. 
templates - це спосіб написати один клас або одну функцію, які можуть працювати з різними типами даних
замість того, щоб писати int sum(int a, int b) і окремо float sum(float a, float b) можна написпти пишеш template<typename T> T sum(T a, T b)
коли викликаєш sum(5, 10), компілятор сам створить версію цієї функції для int. коли викличеш sum(3.5f, 2.1f), він створить версію для float
2.
в c++ немає ArrayList чи List<T>, але роблять це з векторами
arraylist:
це non-generic колекція
зберігає всі елементи як тип object
при додаванні типів-значень (наприклад, int) відбувається boxing – перетворення int на object
при отриманні елементів потрібне зворотне приведення типів та unboxing
не є типобезпечним. помилки, пов'язані з невірним приведенням типів, виникають під час виконання програми
list<t>:
це generic колекція
тип елементів T (наприклад, int у list<int>) вказується при створенні
колекція зберігає елементи безпосередньо вказаного типу T
"упаковка" та "розпакування" для типів-значень не відбувається, що покращує продуктивність
є типобезпечним
компілятор перевіряє відповідність типів на етапі компіляції, запобігаючи помилкам під час виконання
3.
вони відрізняються структурою та способом доступу до даних
list<t>:
це впорядкована колекція елементів
елементи зберігаються у послідовності, в якій їх додали
доступ до елементів відбувається за цілочисельним індексом (позицією), наприклад my_list[0]
призначений для зберігання послідовностей, де важливий порядок
dictionary<tkey,tvalue>:
це колекція, що зберігає пари "ключ-значення"
кожен елемент асоціюється з унікальним ключем
доступ до елементів відбувається за ключем, наприклад my_dict["username"]
призначений для дуже швидкого пошуку, додавання та видалення елементів за ключем
4.
ласичні цикли:
це імперативний підхід
код покроково описує, як потрібно виконати операцію: 
ініціалізувати лічильник, перевірити умову, отримати елемент, виконати дію, збільшити лічильник
код часто виходить великим, особливо для складних фільтрацій чи сортувань
linq:
це декларативний підхід
код описує, що потрібно отримати в результаті, а не як це робити
переваги:
запити виражаються значно коротше і зрозуміліше
використовуються вбудовані, оптимізовані оператори, що зменшує ймовірність помилок
однаковий синтаксис застосовується до різних джерел даних
5.
блок finally є частиною конструкції обробки винятків try catch finally
його головна характеристика - код, розміщений у блоці finally, виконується гарантовано і завжди, незалежно від того, що сталося в блоці try:
якщо try виконався успішно – finally виконується після нього
якщо в try стався виняток і його перехопив catch – finally виконується після catch
якщо в try стався виняток і його не перехопив catch – finally виконується перед тим, як виняток буде передано на вищий рівень
основне призначення finally – гарантоване звільнення критичних ресурсів, щоб уникнути їх витоку
6.
створювати власні класи винятків доцільно, коли стандартних класів винятків недостатньо для точного опису специфічної помилкової ситуації
основні причини:
це дозволяє створювати окремі блоки catch для конкретних помилок, це більш точно, ніж ловити загальний exception або runtime_error
у власний клас винятку можна додати поля, які містять більше інформації про помилку
назва винятку слугує самодокументацією і чітко показує, яке саме правило було порушено