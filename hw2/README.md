# домашня робота №2

порушення lsp: приклади та рішення

## вступ

lsp або принцип підстановки барбари лісков описує правило об’єктно-орієнтованого програмування, згідно з яким об’єкт дочірнього класу повинен без проблем замінювати об’єкт батьківського класу без зміни коректності роботи програми. іншими словами, якщо система працює з базовим типом, вона не повинна помічати різниці, коли замість нього підставляється його нащадок.

## приклади порушення

приклад 1: птах і пінгвін. існує базовий клас bird з методом fly, який описує здатність літати. клас penguin наслідує bird, але не може літати і змушений або кидати помилку, або ігнорувати виклик методу.

приклад 2: файл і тільки для читання файл. є клас file з методами read і write. клас readonlyfile наслідує file, але забороняє запис, тому метод write або нічого не робить, або викликає виняток.

приклад 3: черга і обмежена черга. є клас queue з методом add для додавання елементів. клас boundedqueue має ліміт розміру і при перевищенні цього ліміту перестає приймати елементи, хоча базовий клас цього не передбачає.

## пояснення порушення

у випадку з птахом і пінгвіном код, який очікує, що будь-який bird може літати, отримає об’єкт penguin і зіткнеться з неочікуваною поведінкою. penguin формально є bird, але логічно не може виконувати всі обіцянки базового класу.

у прикладі з файлом система працює з типом file і розраховує, що write завжди доступний. при підстановці readonlyfile ця умова порушується, і код змінює свою поведінку або ламається.

у випадку з чергою клієнтський код очікує, що add завжди додає елемент. boundedqueue вводить нове обмеження, якого не було в контракті базового класу, тому підстановка перестає бути безпечною.

## проблеми

порушення lsp призводить до неочікуваних помилок у рантаймі, коли програма формально компілюється, але працює некоректно. код стає крихким, бо будь-яке розширення ієрархії може зламати існуючу логіку. тестування ускладнюється, оскільки потрібно враховувати особливу поведінку кожного нащадка замість довіри до спільного контракту.

## перепроєктування для дотримання lsp

замість спадкування у таких випадках варто змінювати абстракції. у прикладі з птахами можна винести здатність літати в окремий інтерфейс flyable і реалізовувати його лише для тих класів, які реально літають. тоді penguin залишиться птахом, але не буде змушений підтримувати зайву поведінку.

у випадку з файлами краще мати окремі інтерфейси readable і writable, а не один універсальний клас. readonlyfile реалізує тільки readable, а звичайний file реалізує обидва.

для черги можна замінити спадкування на композицію, де boundedqueue містить всередині звичайну queue і додає власну перевірку ліміту, не порушуючи контракт базового типу.

приклад порушення:
``` cpp
#include <iostream>
using namespace std;

class Bird {
public:
    virtual void fly() {
        cout << "flying" << endl;
    }
};

class Penguin : public Bird {
public:
    void fly() override {
        throw runtime_error("penguin cannot fly");
    }
};
```
виправлений варіант з дотриманням isp:
``` cpp
#include <iostream>
using namespace std;

class Flyable {
public:
    virtual void fly() = 0;
};

class Bird {
};

class Sparrow : public Bird, public Flyable {
public:
    void fly() override {
        cout << "flying" << endl;
    }
};

class Penguin : public Bird {
};
```

## висновок

lsp змушує проєктувати ієрархії так, щоб спадкування відображало реальні відношення між об’єктами, а не просто повторне використання коду. дотримання цього принципу робить систему передбачуваною, стійкою до змін і значно простішою для підтримки та тестування.